#+title: Git
#+index: Git
#+options: num:nil toc:1
* day 7
<2025-12-22 Mon>

I am setting up an agenda to outline my studies leading up to March 31st when
the GiSoC applications are due. I also cloned the git.github.io repo so I can
see all of the developer pages from Emacs. This is important because when they
release those microprojects, I want to be ready to work on them, so I will be
fetching the changes to this repo on Emacs startup. I found the fun Gitstery
repository which is a murder mystery that you can solve by using git commands.
* day 6
<2025-12-21 Sun>

I'm moving all of my private repositories off of github and using git over ssh
to work on them from my laptop.

I learned about rebase and feel enlightened. The words my high school math
teacher told me when he found out that I wanted to study computer science echo
in my head

#+begin_quote
With great power comes great responsibility.
* day 5
<2025-12-07 Sun>

Today I learned how to install git on Windows and helped install git on a
colleagues machine. They use Codium, which seems to be pretty similar to VSCode.
It was satisfying installing git and then seeing their editor now capable of
committing their changes.
* day 4
<2025-12-05 Fri>

Found more resources:
- [[https://www.youtube.com/watch?v=MYn0DHnQggo&t=679][The Zen of Git]] youtube video
- [[https://think-like-a-git.net/sections/experimenting-with-git/references-make-commits-reachable.html][think like a git]] resource
* day 3
<2025-10-17 Fri>
:LOGBOOK:
CLOCK: [2025-10-17 Fri 07:21]--[2025-10-17 Fri 08:07] =>  0:46
:END:
Using the baby-git and Decoding git book, I've found the following resources;
- https://www.gnu.org/software/libc/manual/html_node/index.html
- https://pubs.opengroup.org/onlinepubs/9699919799/
- https://www.cplusplus.com/reference/
- https://zlib.net/manual.html
- https://zlib.net/zlib_how.html

Git uses the SHA-1 hash function to map file contents to hash values.

There are the following four basic components in Git's initial commit:
- objects
- an object database
- a current directory cache
- a working directory
** Objects
Object types:
- blob
- tree
- commit

An object is an abstraction of data and metadata. It is indexed and referenced
through its hash value. The name of an object is its hash value. This hash value
is used to refer and look up to the specific content.

The general structure of an object is:
#+begin_example
object tag
' '                 (single space)
size of object data (in bytes)
'\0'                (null character)
object binary data
#+end_example

The first part of an object consists of the object metadata. The second part
consists of the object data (the binary data). The space and null byte are used
to seperate the two. The object tag is simply what type of object it is (one of:
blob, tree, commit) and the size of the object data in bytes before deflation.

*** Blobs (binary large objects)
Woah that just blew my mind, didn't know blobs are just binary large objects.
Any file that the user adds could be a blob, it sould be the binary
representation of a video, plaintext, or any file. Git generates a blob object
that is named, indexed and referenced through the deflated blob objects SHA-1
hash value.

*** Tree object
A tree object contains a list of files aded to a repository. each file has a
mode, path and sha-1 hash. The size of the tree is the sum of the sizes of the
file information entries in the tree object data.

*** Commit object
A commit contains the hash value of a tree object being committed ahd the hash
value of any parent tree objects specified by the user, metadata about the user
who committed the tree, the time and date when the commit was made and a
user-supplied comment known today as the commit message.
* day 2
<2025-10-14 Tue>
:LOGBOOK:
CLOCK: [2025-10-14 Tue 11:18]--[2025-10-14 Tue 11:57] =>  0:39
:END:

Today I am exploring the git source code and trying to figure out how things
work.
** Finding list of commands
Git has lots of commands. Here is how you can find where the commands are in the
source. I used the command
#+begin_src sh
grep -nr "list of commands"
#+end_src

to find that there is a list of commands in the git.c file;

#+begin_example
Documentation/MyFirstContribution.adoc:220:The list of commands lives in `git.c`.
#+end_example

In that file is the list of commands. Here are the first and last five;

#+begin_example
"add"
"am"
"annotate"
"apply"
"archive"
...
"verify-tag"
"version"
"whatchanged"
"worktree"
"write-tree"
#+end_example
** How does git add work?
Let's focus on a command I've probably used hundreds of times already:

#+begin_src sh
git add
#+end_src

We can find the following in builtins/add.c;

#+begin_src C
static struct option builtin_add_options[] = {
  OPT__DRY_RUN(&show_only, N_("dry run")),
  OPT__VERBOSE(&verbose, N_("be verbose")),
  OPT_GROUP(""),
  OPT_BOOL('i', "interactive", &add_interactive, N_("interactive picking")),
  OPT_BOOL('p', "patch", &patch_interactive, N_("select hunks interactively")),
  OPT_DIFF_UNIFIED(&add_p_opt.context),
  OPT_DIFF_INTERHUNK_CONTEXT(&add_p_opt.interhunkcontext),
  OPT_BOOL('e', "edit", &edit_interactive, N_("edit current diff and apply")),
  OPT__FORCE(&ignored_too, N_("allow adding otherwise ignored files"), 0),
  OPT_BOOL('u', "update", &take_worktree_changes, N_("update tracked files")),
  OPT_BOOL(0, "renormalize", &add_renormalize, N_("renormalize EOL of tracked files (implies -u)")),
  OPT_BOOL('N', "intent-to-add", &intent_to_add, N_("record only the fact that the path will be added later")),
  OPT_BOOL('A', "all", &addremove_explicit, N_("add changes from all tracked and untracked files")),
  OPT_CALLBACK_F(0, "ignore-removal", &addremove_explicit,
                 NULL /* takes no arguments */,
                 N_("ignore paths removed in the working tree (same as --no-all)"),
                 PARSE_OPT_NOARG, ignore_removal_cb),
  OPT_BOOL( 0 , "refresh", &refresh_only, N_("don't add, only refresh the index")),
  OPT_BOOL( 0 , "ignore-errors", &ignore_add_errors, N_("just skip files which cannot be added because of errors")),
  OPT_BOOL( 0 , "ignore-missing", &ignore_missing, N_("check if - even missing - files are ignored in dry run")),
  OPT_BOOL(0, "sparse", &include_sparse, N_("allow updating entries outside of the sparse-checkout cone")),
  OPT_STRING(0, "chmod", &chmod_arg, "(+|-)x",
             N_("override the executable bit of the listed files")),
  OPT_HIDDEN_BOOL(0, "warn-embedded-repo", &warn_on_embedded_repo,
                  N_("warn when adding an embedded repository")),
  OPT_PATHSPEC_FROM_FILE(&pathspec_from_file),
  OPT_PATHSPEC_FILE_NUL(&pathspec_file_nul),
  OPT_END(),
};
#+end_src

Okay ... That is how it works.
* day 1
:LOGBOOK:
CLOCK: [2025-10-13 Mon 12:56]--[2025-10-13 Mon 13:47] =>  0:51
:END:
<2025-10-13 Mon>

Here are some resources I'm looking into:
- [[https://github.com/ragtux/cnility][k&r]]

- [[https://bitbucket.org/jacobstopak/baby-git][baby-git]]

- [[https://git-scm.com/book/en/v2][pro git]]

- [[https://gitexercises.fracz.com/][git exercises]]

** TIL about git shortlog
This feature is awesome, you can use it to easily see how many commits people
are making to a repository. With the command
#+begin_src sh
git shortlog -ns
#+end_src
you are able to see who has committed the most to a repository. Here is the
output of that command on the git repo;
#+begin_example
 27457  Junio C Hamano
  4611  Jeff King
  2390  Johannes Schindelin
  1945  Ævar Arnfjörð Bjarmason
  1824  Nguyễn Thái Ngọc Duy
  1810  Patrick Steinhardt
  1401  Shawn O. Pearce
  1314  René Scharfe
  1203  Elijah Newren
  1118  Linus Torvalds
   954  Michael Haggerty
   902  brian m. carlson
#+end_example
Fascinating. Junio C Hamano is legendary!
* git baby steps
<2025-08-24 Sun>

My goal is to improve enough such that I am able to communicate and contribute
to whatever project.

These notes are meant to serve as a roadmap for people that come after me, and
are looking to learn enough to be useful and contribute to git.
